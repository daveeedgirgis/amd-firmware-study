<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firmware Architecture - AMD Study Guide</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <h1 class="logo">AMD Firmware Study</h1>
            <button class="menu-toggle" aria-label="Toggle menu">☰</button>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="firmware-arch.html" class="active">Firmware Architecture</a></li>
                <li><a href="qa-concepts.html">QA Concepts</a></li>
                <li><a href="programming.html">Programming</a></li>
                <li><a href="debugging.html">Debugging</a></li>
                <li><a href="tools.html">Tools & Systems</a></li>
                <li><a href="interview.html">Interview Prep</a></li>
                <li><a href="quiz.html">Quiz</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <header>
            <h1>Firmware Architecture</h1>
            <p>Understanding the fundamentals of firmware architecture, boot processes, and hardware interfaces</p>
        </header>

        <section class="topic-section" data-category="basics">
            <div class="card">
                <h3>Boot Process Overview</h3>
                <p>The boot process is a critical sequence that brings a system from power-on to a running operating system.</p>

                <h4>Boot Flow Stages</h4>
                <ul class="concept-list">
                    <li><strong>ROM (Read-Only Memory):</strong> First code that executes on power-on. Contains Boot ROM code that's immutable and hardcoded during chip manufacturing.</li>
                    <li><strong>Bootloader:</strong> Initializes essential hardware (memory controllers, clocks), loads the next stage from storage.</li>
                    <li><strong>Kernel:</strong> Operating system kernel initialization, device driver loading.</li>
                    <li><strong>OS (Operating System):</strong> Full system boot, user space initialization.</li>
                </ul>

                <div class="info-box important">
                    <div class="info-box-title">Key Concept</div>
                    Each stage verifies and loads the next stage, creating a "chain of trust" for security.
                </div>

                <h4>Typical AMD SoC Boot Sequence</h4>
                <div class="code-example">
                    <pre>
1. Power-On Reset (POR)
   └─> On-chip Boot ROM executes

2. Boot ROM
   ├─> Initialize minimal hardware
   ├─> Verify secure boot fuses
   └─> Load Platform Security Processor (PSP) firmware

3. PSP Firmware
   ├─> Establish root of trust
   ├─> Initialize security subsystem
   └─> Verify and load UEFI/BIOS

4. UEFI/BIOS
   ├─> Initialize DDR memory
   ├─> Initialize PCIe, SATA, USB
   └─> Load OS bootloader

5. OS Bootloader (GRUB/Windows Boot Manager)
   └─> Load operating system kernel
                    </pre>
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="security">
            <div class="card">
                <h3>Secure Boot</h3>
                <p>Secure boot ensures that only trusted, signed firmware can execute on the system.</p>

                <h4>Components of Secure Boot</h4>
                <ul class="concept-list">
                    <li><strong>Fuses:</strong> One-time programmable (OTP) bits in hardware that store security configuration (e.g., public key hashes, security enables)</li>
                    <li><strong>Signing:</strong> Cryptographic signatures (RSA/ECDSA) on firmware binaries</li>
                    <li><strong>Trust Anchors:</strong> Root public keys stored in hardware/fuses that verify the signature chain</li>
                    <li><strong>Chain of Trust:</strong> Each stage verifies the next before execution</li>
                </ul>

                <h4>Secure Boot Verification Process</h4>
                <div class="code-example">
                    <pre>
Boot ROM contains hardcoded public key hash
    ↓
Verify PSP firmware signature using public key
    ↓
If valid → Execute PSP firmware
If invalid → Halt boot / Enter recovery mode
    ↓
PSP verifies BIOS signature
    ↓
BIOS verifies OS bootloader (UEFI Secure Boot)
                    </pre>
                </div>

                <div class="info-box warning">
                    <div class="info-box-title">Testing Consideration</div>
                    In pre-silicon environments, secure boot features must be carefully validated including signature verification, rollback protection, and fuse configurations.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="hardware">
            <div class="card">
                <h3>Memory-Mapped I/O (MMIO)</h3>
                <p>MMIO is a method of accessing hardware registers using memory addresses.</p>

                <h4>Key Concepts</h4>
                <ul class="concept-list">
                    <li><strong>Register Maps:</strong> Hardware modules expose configuration and status registers at specific memory addresses</li>
                    <li><strong>Base Address Register (BAR):</strong> Starting address for a device's register space</li>
                    <li><strong>Offset:</strong> Register location relative to base address</li>
                    <li><strong>Endianness:</strong> Byte order (little-endian vs big-endian) for multi-byte values</li>
                </ul>

                <h4>Example: Writing to a Hardware Register</h4>
                <div class="code-example">
                    <pre>
// C example of MMIO access
#define GPIO_BASE_ADDR  0xFED80000
#define GPIO_CONFIG_REG 0x0100

volatile uint32_t *reg = (uint32_t *)(GPIO_BASE_ADDR + GPIO_CONFIG_REG);
*reg = 0x00000001;  // Set bit 0 to enable GPIO

// Reading from register
uint32_t status = *reg;
                    </pre>
                </div>

                <div class="info-box tip">
                    <div class="info-box-title">Verification Tip</div>
                    Always verify register access width (8/16/32/64-bit) and alignment requirements. Misaligned accesses can cause exceptions or silent failures.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="hardware">
            <div class="card">
                <h3>Interrupt Handling</h3>
                <p>Interrupts allow hardware to signal the processor about events requiring attention.</p>

                <h4>Interrupt Types</h4>
                <ul class="concept-list">
                    <li><strong>Hardware Interrupts:</strong> Generated by external devices (timers, I/O peripherals)</li>
                    <li><strong>Software Interrupts:</strong> Triggered by software instructions (syscalls)</li>
                    <li><strong>Exceptions:</strong> Synchronous interrupts from error conditions (divide by zero, page fault)</li>
                </ul>

                <h4>Interrupt Controller</h4>
                <ul class="concept-list">
                    <li><strong>APIC (Advanced Programmable Interrupt Controller):</strong> Modern x86 interrupt handling</li>
                    <li><strong>Interrupt Vector:</strong> Number identifying specific interrupt source</li>
                    <li><strong>Interrupt Service Routine (ISR):</strong> Handler function executed when interrupt fires</li>
                    <li><strong>Priority Levels:</strong> Some interrupts can preempt others</li>
                </ul>

                <div class="info-box important">
                    <div class="info-box-title">Common Bug</div>
                    Interrupt misconfiguration: Wrong vector number, unmasked interrupt during initialization, or interrupt storm (device continuously triggering interrupts).
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="hardware">
            <div class="card">
                <h3>Watchdog Timers</h3>
                <p>Hardware timer that resets the system if software fails to "pet the dog" within a timeout period.</p>

                <h4>Purpose</h4>
                <ul class="concept-list">
                    <li>Detect and recover from software hangs</li>
                    <li>Ensure system doesn't remain in a frozen state</li>
                    <li>Critical for embedded and safety-critical systems</li>
                </ul>

                <h4>Operation</h4>
                <div class="code-example">
                    <pre>
// Pseudo-code for watchdog operation
init_watchdog(timeout_ms = 5000);  // 5 second timeout

while (system_running) {
    perform_work();
    kick_watchdog();  // Reset timer before it expires
}

// If kick_watchdog() not called within 5s → hardware reset
                    </pre>
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="hardware">
            <div class="card">
                <h3>Clocks and PLLs</h3>
                <p>Managing system timing and frequency generation.</p>

                <h4>Clock Domains</h4>
                <ul class="concept-list">
                    <li><strong>System Clock:</strong> Main CPU/SoC clock</li>
                    <li><strong>Peripheral Clocks:</strong> Individual clocks for I/O devices</li>
                    <li><strong>Memory Clock:</strong> DDR memory interface clock</li>
                </ul>

                <h4>PLL (Phase-Locked Loop)</h4>
                <ul class="concept-list">
                    <li>Generates high-frequency clocks from a reference oscillator</li>
                    <li>Allows frequency multiplication and division</li>
                    <li>Must be properly configured and locked before system operation</li>
                </ul>

                <div class="info-box warning">
                    <div class="info-box-title">Verification Point</div>
                    Clock initialization order matters! Peripherals should not access their registers before their clocks are enabled and stable.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="debug">
            <div class="card">
                <h3>Debug Interfaces</h3>
                <p>Hardware interfaces used for debugging firmware during development and verification.</p>

                <h4>UART (Universal Asynchronous Receiver/Transmitter)</h4>
                <ul class="concept-list">
                    <li>Serial communication protocol for debug logging</li>
                    <li>Simple, widely supported, low-overhead</li>
                    <li>Typically used for console output and early boot messages</li>
                    <li>Configuration: baud rate (e.g., 115200), parity, stop bits</li>
                </ul>

                <h4>JTAG (Joint Test Action Group)</h4>
                <ul class="concept-list">
                    <li>Hardware debugging and boundary scan interface</li>
                    <li>Allows reading/writing memory and registers</li>
                    <li>Can halt CPU execution and single-step through code</li>
                    <li>Used with debuggers like OpenOCD, Lauterbach</li>
                </ul>

                <h4>ICE (In-Circuit Emulator)</h4>
                <ul class="concept-list">
                    <li>Advanced debugging tool that provides real-time trace</li>
                    <li>Can capture instruction execution history</li>
                    <li>Useful for debugging timing-sensitive issues</li>
                </ul>

                <div class="info-box tip">
                    <div class="info-box-title">Pre-Silicon Debugging</div>
                    In simulation environments, you'll use waveform viewers and simulation logs instead of hardware debug interfaces. Understanding the mapping between hardware and simulation debug methods is crucial.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="advanced">
            <div class="card">
                <h3>BIOS/UEFI Firmware</h3>
                <p>Understanding the firmware layer that initializes hardware before the OS boots.</p>

                <h4>BIOS vs UEFI</h4>
                <div class="code-example">
                    <pre>
Legacy BIOS:
├─> 16-bit real mode
├─> Limited to MBR partitioning (2TB disks)
├─> Text-based setup interface
└─> Simple INT 13h disk access

UEFI (Unified Extensible Firmware Interface):
├─> 32/64-bit protected mode
├─> Supports GPT partitioning (>2TB disks)
├─> Graphical setup interface
├─> Modular driver model
├─> Secure Boot support
└─> Network boot capabilities
                    </pre>
                </div>

                <h4>UEFI Boot Process</h4>
                <ul class="concept-list">
                    <li><strong>SEC (Security Phase):</strong> First code execution, initialize temporary memory</li>
                    <li><strong>PEI (Pre-EFI Initialization):</strong> Initialize RAM, prepare for DXE</li>
                    <li><strong>DXE (Driver Execution Environment):</strong> Load drivers, initialize devices</li>
                    <li><strong>BDS (Boot Device Selection):</strong> Select and load OS bootloader</li>
                    <li><strong>RT (Runtime):</strong> Provide runtime services to OS</li>
                </ul>

                <div class="code-example">
                    <pre>
// Example UEFI Runtime Services used by OS
GetTime()           // Read real-time clock
SetTime()           // Set real-time clock
GetVariable()       // Read NVRAM variable
SetVariable()       // Write NVRAM variable
ResetSystem()       // Reboot/shutdown system
                    </pre>
                </div>

                <div class="info-box important">
                    <div class="info-box-title">Verification Focus</div>
                    Verify each UEFI phase completes successfully, drivers load correctly, and runtime services work after OS handoff. Common issues: missing drivers, incorrect boot order, NVRAM corruption.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="advanced">
            <div class="card">
                <h3>Firmware Update & Recovery</h3>
                <p>Mechanisms for updating firmware and recovering from failures.</p>

                <h4>Firmware Update Methods</h4>
                <ul class="concept-list">
                    <li><strong>In-Band Update:</strong> OS-based update tools (Windows Update, Linux fwupd)</li>
                    <li><strong>Out-of-Band Update:</strong> BMC or management controller updates firmware</li>
                    <li><strong>Capsule Update:</strong> UEFI capsule delivered before OS boot</li>
                    <li><strong>Recovery Mode:</strong> Minimal firmware to reflash from USB/network</li>
                </ul>

                <h4>Update Verification Steps</h4>
                <div class="code-example">
                    <pre>
1. Signature Verification
   └─> Verify update package is signed by trusted key

2. Version Check
   ├─> Ensure update is newer (prevent downgrade)
   └─> Check compatibility with hardware revision

3. Backup Current Firmware
   └─> Save working firmware to recovery partition

4. Flash New Firmware
   ├─> Erase old firmware
   ├─> Program new firmware
   └─> Verify written data matches expected

5. Activate New Firmware
   ├─> Update boot pointers
   └─> Mark new firmware as active

6. Reboot and Verify
   └─> Boot with new firmware, run POST tests
                    </pre>
                </div>

                <h4>A/B Firmware Partitioning</h4>
                <ul class="concept-list">
                    <li>Two firmware copies: A (active) and B (backup)</li>
                    <li>Update writes to inactive partition</li>
                    <li>If update succeeds, switch active partition</li>
                    <li>If boot fails, automatically fallback to previous version</li>
                </ul>

                <div class="info-box warning">
                    <div class="info-box-title">Critical Test Cases</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Power loss during update - verify recovery works</li>
                        <li>Corrupted update package - reject with clear error</li>
                        <li>Downgrade attack - prevent rollback to vulnerable version</li>
                        <li>Failed boot after update - automatic recovery to previous</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="advanced">
            <div class="card">
                <h3>Power Management in Firmware</h3>
                <p>ACPI states and firmware's role in power management.</p>

                <h4>ACPI Power States</h4>
                <div class="code-example">
                    <pre>
Global States (G-states):
G0 - Working (system fully on)
G1 - Sleeping (subdivided into S-states)
G2 - Soft Off (mechanical off, power button responsive)
G3 - Mechanical Off (completely powered down)

Sleep States (S-states):
S0 - Working
S1 - CPU stopped, RAM powered (rare)
S2 - CPU off, dirty cache flushed (rare)
S3 - Suspend to RAM (sleep mode)
S4 - Suspend to Disk (hibernate)
S5 - Soft Off

CPU States (C-states):
C0 - Active (executing instructions)
C1 - Halt (CPU stopped, cache maintained)
C2 - Stop Clock (clocks stopped, cache maintained)
C3 - Sleep (caches flushed, slower wake)
C6+ - Deep Sleep (very low power)

Performance States (P-states):
P0 - Maximum performance (highest frequency)
P1, P2, ... - Progressively lower performance/power
                    </pre>
                </div>

                <h4>Firmware Responsibilities</h4>
                <ul class="concept-list">
                    <li>Initialize ACPI tables (FADT, DSDT, SSDT)</li>
                    <li>Implement S3 resume path (restore hardware state)</li>
                    <li>Configure CPU C-state and P-state limits</li>
                    <li>Handle power button and lid events</li>
                    <li>Manage device D-states (D0=on, D3=off)</li>
                </ul>

                <div class="code-example">
                    <pre>
// S3 Suspend/Resume Flow
Suspend (S0 → S3):
1. OS saves context to RAM
2. Firmware receives S3 sleep command
3. Put devices in D3 (off) state
4. Configure wake events (keyboard, USB, RTC)
5. Enter S3 (RAM self-refresh, everything else off)

Resume (S3 → S0):
1. Wake event triggers (button, timer, USB)
2. Firmware resumes execution
3. Re-initialize memory controller (DDR still has data!)
4. Restore CPU context
5. Jump to OS resume vector
6. OS restores devices and applications
                    </pre>
                </div>

                <div class="info-box tip">
                    <div class="info-box-title">Common S3 Resume Bugs</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Forgetting to restore hardware register state</li>
                        <li>DDR training on resume (slow and wrong - DDR stays on!)</li>
                        <li>Incorrect wake source configuration</li>
                        <li>Cache coherency issues after CPU context restore</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="advanced">
            <div class="card">
                <h3>Firmware Data Structures</h3>
                <p>Key data structures firmware uses to describe hardware to the OS.</p>

                <h4>ACPI Tables</h4>
                <ul class="concept-list">
                    <li><strong>RSDP:</strong> Root System Description Pointer - entry point to ACPI</li>
                    <li><strong>RSDT/XSDT:</strong> Root/Extended System Description Table - lists all other tables</li>
                    <li><strong>FADT:</strong> Fixed ACPI Description Table - hardware register addresses</li>
                    <li><strong>DSDT:</strong> Differentiated System Description Table - device tree in AML</li>
                    <li><strong>SSDT:</strong> Secondary System Description Table - additional devices</li>
                    <li><strong>MADT:</strong> Multiple APIC Description Table - CPU and interrupt info</li>
                    <li><strong>SRAT:</strong> System Resource Affinity Table - NUMA topology</li>
                </ul>

                <h4>Device Tree (Arm/Embedded)</h4>
                <div class="code-example">
                    <pre>
// Device Tree Example (DTS format)
/ {
    cpus {
        cpu@0 {
            device_type = "cpu";
            compatible = "arm,cortex-a72";
            reg = <0x0>;
            clock-frequency = <1800000000>; // 1.8 GHz
        };
    };

    memory@80000000 {
        device_type = "memory";
        reg = <0x80000000 0x40000000>; // 1GB at 0x80000000
    };

    uart@fe001000 {
        compatible = "ns16550a";
        reg = <0xfe001000 0x1000>;
        interrupts = <33>;
        clock-frequency = <50000000>;
    };
};
                    </pre>
                </div>

                <h4>SMBIOSType 0 (BIOS Information)</h4>
                <div class="code-example">
                    <pre>
struct smbios_type0 {
    uint8_t  type;             // 0
    uint8_t  length;
    uint16_t handle;
    uint8_t  vendor;           // String index
    uint8_t  bios_version;     // String index
    uint16_t bios_segment;
    uint8_t  bios_release_date;
    uint8_t  bios_rom_size;
    uint64_t characteristics;
    // ... more fields
};

// OS reads this to get BIOS version, vendor, features
                    </pre>
                </div>

                <div class="info-box important">
                    <div class="info-box-title">Verification</div>
                    Validate all ACPI/SMBIOS tables are correctly formatted and contain accurate hardware information. Use OS tools (acpidump, dmidecode) to inspect tables and verify against hardware specs.
                </div>
            </div>
        </section>

        <section class="topic-section" data-category="advanced">
            <div class="card">
                <h3>Firmware Security Features</h3>
                <p>Modern security mechanisms implemented in firmware.</p>

                <h4>Measured Boot (TPM)</h4>
                <ul class="concept-list">
                    <li>Each boot stage measures (hashes) the next stage before executing it</li>
                    <li>Measurements stored in TPM (Trusted Platform Module) PCRs</li>
                    <li>Creates cryptographic log of boot process</li>
                    <li>OS can verify boot integrity by checking PCR values</li>
                    <li>Different from Secure Boot: doesn't prevent execution, only records</li>
                </ul>

                <div class="code-example">
                    <pre>
Measured Boot Flow:
1. Boot ROM measures PSP firmware → extends PCR[0]
2. PSP measures UEFI BIOS → extends PCR[0]
3. UEFI measures bootloader → extends PCR[4]
4. Bootloader measures kernel → extends PCR[8]
5. OS verifies PCRs match expected values (attestation)
                    </pre>
                </div>

                <h4>Intel Boot Guard / AMD Hardware Validated Boot</h4>
                <ul class="concept-list">
                    <li>OEM fuses contain hash of initial bootblock</li>
                    <li>CPU verifies bootblock before execution (in microcode)</li>
                    <li>Establishes root of trust in CPU, not firmware</li>
                    <li>Prevents firmware-level rootkits</li>
                </ul>

                <h4>SMM (System Management Mode) Security</h4>
                <ul class="concept-list">
                    <li>Special CPU mode with highest privileges</li>
                    <li>Used for low-level hardware management</li>
                    <li>Isolated memory (SMRAM) hidden from OS</li>
                    <li>Entry only via SMI (System Management Interrupt)</li>
                    <li>Vulnerabilities in SMM code = full system compromise</li>
                </ul>

                <div class="info-box warning">
                    <div class="info-box-title">Security Testing</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Verify SMRAM is locked and inaccessible to OS</li>
                        <li>Test SMI handlers for buffer overflows</li>
                        <li>Ensure TPM PCRs accurately reflect boot components</li>
                        <li>Test secure boot with revoked certificates</li>
                        <li>Verify firmware rollback protection works</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="qa-section">
            <h2>Common Q&A</h2>
            <div class="card">
                <div class="qa-item">
                    <div class="question">
                        What happens if secure boot verification fails?
                        <span class="toggle-icon">▶</span>
                    </div>
                    <div class="answer">
                        The system typically halts the boot process to prevent execution of unsigned/untrusted code. Depending on the implementation, it may:
                        <ul>
                            <li>Enter a recovery mode allowing reflash via a secure mechanism</li>
                            <li>Display an error code via LED or debug port</li>
                            <li>Completely halt requiring a hardware recovery procedure</li>
                        </ul>
                        This is a critical security feature that prevents unauthorized firmware from running.
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">
                        How do you verify firmware correctly initializes DDR memory?
                        <span class="toggle-icon">▶</span>
                    </div>
                    <div class="answer">
                        DDR initialization verification involves multiple steps:
                        <ul>
                            <li>Check memory controller configuration registers (timing, voltage, mode)</li>
                            <li>Verify training sequences complete successfully (write leveling, read leveling)</li>
                            <li>Run memory tests (pattern writes/reads, stress tests)</li>
                            <li>Validate error correction (ECC) if enabled</li>
                            <li>Monitor for correct access patterns in waveforms (simulation)</li>
                        </ul>
                        Incorrect DDR init is a common source of early boot failures.
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">
                        What's the difference between little-endian and big-endian?
                        <span class="toggle-icon">▶</span>
                    </div>
                    <div class="answer">
                        Endianness defines byte order for multi-byte values:
                        <br><br>
                        <strong>Little-Endian:</strong> Least significant byte at lowest address (x86/AMD uses this)
                        <br>Value 0x12345678 stored as: [78] [56] [34] [12]
                        <br><br>
                        <strong>Big-Endian:</strong> Most significant byte at lowest address (network protocols, some ARM)
                        <br>Value 0x12345678 stored as: [12] [34] [56] [78]
                        <br><br>
                        This matters when accessing hardware registers, reading firmware images, or communicating between systems with different endianness.
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">
                        How do interrupts work at the hardware level?
                        <span class="toggle-icon">▶</span>
                    </div>
                    <div class="answer">
                        When a hardware device needs CPU attention:
                        <ul>
                            <li>Device asserts an interrupt line (physical signal to interrupt controller)</li>
                            <li>Interrupt controller determines priority and vector number</li>
                            <li>CPU finishes current instruction, saves context (registers, PC)</li>
                            <li>CPU looks up Interrupt Service Routine (ISR) address from interrupt vector table</li>
                            <li>ISR executes, handles the event, acknowledges interrupt</li>
                            <li>CPU restores context and resumes previous execution</li>
                        </ul>
                        Proper interrupt handling is critical for system responsiveness and stability.
                    </div>
                </div>
            </div>
        </section>
    </main>

    <div class="scroll-top">↑</div>

    <footer>
        <p>AMD Firmware Verification Study Guide</p>
    </footer>

    <script src="script.js"></script>
    <script>
        // Mark topic as viewed for progress tracking
        markTopicViewed('firmware');
    </script>
</body>
</html>
